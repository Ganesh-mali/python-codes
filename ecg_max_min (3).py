# -*- coding: utf-8 -*-
"""ECG_MAX_MIN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QAD1QrcBaRWgRtUaOFnWi3uukmoQMght
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
y = pd.read_csv('f0.txt')              # reading dataset 
x = np.linspace( 0, 5.8, 5.8*500)      # 1sec =500 values so 5.8 sec =>5.8*500 values

temp=y.shape                           # creating temp var for rearranging data
x=x[0:temp[0]]                          # making x now of row exactly same as no of rows of temp i.e of y 
plt.axis([0, 5.8, -1, 1])               #  specifying min max values of x axis and y axis

y=y.values                                 # converting pd dataframe into NdArray
print(len(y))
peaks = np.where((y[1:-1] > y[0:-2]) * (y[1:-1] > y[2:]))[0] + 1            #for local  max
dips = np.where((y[1:-1] < y[0:-2]) * (y[1:-1] < y[2:]))[0] + 1              #for local min

# The above makes a list of all indices where the value of y[i] is greater than both of its neighbours
# It does not check the endpoints, which only have one neighbour each
# The extra +1 at the end is necessary because where finds the indices within the slice y[1:-1],
# not the full array y. The [0] is necessary because where returns a tuple of arrays, where the first element 
# is the array we want.
i=0  
plt.plot (x, y)
while(i<len(y[peaks])):
  if y[peaks][i]>0.4:                                              #set max value to plot
    plt.plot (x[peaks][i], y[peaks][i], 'o')
  i+=1

i=0
while(i<len(y[dips])):
  if y[dips][i]<-0.48:                                           # set min value to plot
    plt.plot (x[dips][i], y[dips][i], 'o') 
  i+=1

plt.show()